# 376. 摆动序列

[Leedcode 链接🔗](https://leetcode.cn/problems/wiggle-subsequence/description/)  
[Code](https://github.com/alstondu/lc/blob/main/376/376.cpp)

### 题目

如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。

例如， ```[1, 7, 4, 9, 2, 5]``` 是一个 摆动序列 ，因为差值 ```(6, -3, 5, -7, 3)``` 是正负交替出现的。

相反，```[1, 4, 7, 2, 5]``` 和 ```[1, 7, 4, 5, 5]``` 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。
子序列 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。

给你一个整数数组 ```nums``` ，返回 ```nums``` 中作为 摆动序列 的 最长子序列的长度 。

---

### 示例
#### 示例 1：

**输入**：```nums = [1,7,4,9,2,5]```

**输出**：```6```

**解释**：整个序列均为摆动序列，各元素之间的差值为 ```(6, -3, 5, -7, 3)``` 。

---

### 算法：  

不需要建立新的数组，只要遍历原始数组并在摆动出现时计数。

摆动的出现可以被定义为 ```preDiff``` 和 ```curDiff``` 一正一负，但有三个特殊处理：

1. 重复元素导致非单调平坡： 上-平-下 / 下-平-上

	重复的元素只考虑最右边的一个，因此 ```preDiff = 0``` 但 ```curDiff``` 大于或小于 ```0``` 时也算发现摆动。
	
2. 数组首末：

	上述逻辑要求数组 ```size``` 至少为 3 。当小于 3 时，假设数组首个元素前有一个相同的元素，即 ```preDiff = 0```, 则上述逻辑可以将其一并处理（两元素相同则 ```preDiff = 0， CurDiff = 0```，不算，不同则```preDiff = 0, curDiff > 0 / < 0）```, 算）。于此同时，认定数组末尾元素为一个摆动， ```result```初始化为 1。

	⚠️ 由于最后一个元素默认摆动，遍历数组时不需要遍历最后一个元素。

3. 重复元素导致单调平坡： 上-平-上 / 下-平-下

	令 ```preDiff```只有在发生摆动时才更新，而不是实时跟着 ```curDiff```, 在此情况出现时就不会 ```preDiff = 0, curDiff > 0 / < 0```, 而此时 ```preDiff``` 只会记录上一次的坡度，从而避免这种情况导致的误算。