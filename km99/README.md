# km99. 岛屿数量

[Leedcode 链接🔗](https://kamacoder.com/problempage.php?pid=1171)  
[Code](https://github.com/alstondu/lc/blob/main/km99/km99.cpp)

### 题目

给定一个由 `1`（陆地）和 `0`（水）组成的矩阵，你需要计算岛屿的数量。岛屿由水平方向或垂直方向上相邻的陆地连接而成，并且四周都是水域。你可以假设矩阵外均被水包围。

#### 输入描述

第一行包含两个整数 `N, M`，表示矩阵的行数和列数。

后续 `N` 行，每行包含 `M` 个数字，数字为 `1` 或者 `0`。

#### 输出描述

输出一个整数，表示岛屿的数量。如果不存在岛屿，则输出 `0`。

---

#### 示例：

#### 示例 1:

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20240516111613.png" alt="">

**输入**：

```
4 5
1 1 0 0 0
1 1 0 0 0
0 0 1 0 0
0 0 0 1 1
```

**输出**：

```
3
```

---

### 算法:

#### 图存储

1. **邻接矩阵：**

	n 个节点，节点从 1 开始算，为了下标对其，创建 `(n + 1) * (n + 1)` 大小的矩阵, 矩阵的每个位置代表的是对应行列的两个节点之间边的值，全初始化为 0， 然后再根据输入把对应的有边的位置赋值。
	
	```c++
	while (m--){
		cin >> s >> t;
		grid[s][t] = 1;
	}
	```

2. **邻接表：**

	构建数组储存节点，大小为 `n + 1 `（对齐下标）
	
	```c++
	vector<list<int>> graph(n + 1);
	```
	把输入的边 push 到相应的节点的链表中
	
	```c++
	while (m--){
		cin >> s >> t;
		graph[s].push_back(t);
	}
```

递归 + 回溯

递归传入图，当前 int 节点，终止 int 节点

当前节点等于终止节点时递归结束，储存路径

遍历当前节点所能连接的所有节点，找到有边的节点进行递归和回溯