# 198. 打家劫舍

[Leedcode 链接🔗](https://leetcode.cn/problems/house-robber/description/)  
[Code](https://github.com/alstondu/lc/blob/main/198/198.cpp)

### 题目

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你不触动警报装置的情况下，一夜之内能够偷窃到的最高金额。

---

#### 示例：

#### 示例 1：

**输入**：```[1,2,3,1]```

**输出**：```4```

**解释**：

偷窃 ```1``` 号房屋 (金额 = 1)，然后偷窃 ```3``` 号房屋 (金额 = 3)。

偷窃到的最高金额 = 1 + 3 = 4 。

#### 示例 2：

**输入**：```[2,7,9,3,1]```

**输出**：```12```

**解释**：

偷窃 ```1``` 号房屋 (金额 = 2), 偷窃 ```3``` 号房屋 (金额 = 9)，接着偷窃 ```5``` 号房屋 (金额 = 1)。
     
偷窃到的最高金额 = 2 + 9 + 1 = 12 。

---

### 算法:


1.  ```dp```数组定义：
	
	对于给定房屋的下标 i，所能偷窃的最大金额为 ```dp[i]```。	  		  	 
2. 递推公式：
	
	对于当前房屋，可以选择偷或者不偷，偷的话因为只能间隔行窃，截止上一个被偷的房屋所能偷的最大金额为 ```dp[i - 2]```，加上当前房屋的金额，为 ```dp[i - 2] + nums[i]```。不偷的话则当前最大金额不变，为前一个房屋的金额，也就是 ```dp[i - 1]```。二者取大者。

	  	```dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])```

  
3. ```dp``` 数组初始化：

	当前 ```dp```值由前两个推导而来，因此要初始化 ```dp[0]``` 和 ```dp[1]```。```dp[0]```代表只有最开始下标为 0 的一家，因此能获得的最大值肯定是偷，因此初始化为 ```nums[0]```。```dp[1]```代表偷前两家，因此选择大者，初始化为 ```max(nums[0], nums[1])```。

4. 遍历顺序：
	
	从前向后遍历。
  
5. 打印```dp```数组

⚠️因为```for ```循环要访问 ```nums[0], nums[1]``` 和 ```nums[2]```，要对空数组和数组中只有一个元素的情况进行单独处理。