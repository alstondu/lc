# 718. 最长重复子数组

[Leedcode 链接🔗](https://leetcode.cn/problems/maximum-length-of-repeated-subarray/description/)  
[Code](https://github.com/alstondu/lc/blob/main/718/718.cpp)

### 题目

给两个整数数组 `nums1` 和 `nums2` ，返回两个数组中公共的、长度最长的子数组的长度 。

---

#### 示例：

#### 示例 1：

**输入**：`nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]`

**输出**：`3`

**解释**：长度最长的公共子数组是 `[3,2,1]` 。

#### 示例 2：

**输入**：`nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]`

**输出**：`5`

---

### 算法:

 
1.  ```dp```数组定义：
	
	```dp[i][j]```表示在以 `i - 1` 为结尾的 `nums1` 和以 `j - 1` 为结尾的 `nums2` 的最长重复字数组的长度为 `dp[i][j]`。
		  		  	 
2. 递推公式：
	
	本题的重复字数组是连续的，因此当两个数组中相同元素被找到后，二者同时向后的一位即可 + 1。
  
3. ```dp``` 数组初始化：

	因为```dp[i][j]```表示在以 `i - 1` 和 `j - 1`为结尾的数组，因此遍历时应该从 `i = 1` 和 `j = 1`开始，且 `dp[i][0]` 和 `dp[0][j]` 是没有意义的，初始化为 0 来进行之后从 1 开始的递推。
	
	其他的元素在没有找到共同字数组时为 `0`，代表重复字数组长度为 `0`。

4. 遍历顺序：
	
	从前向后遍历二维数组，但是边界条件为 `i` 和 `j`，代表下标为 `i - 1` 和 `j - 1` 的元素。
  
5. 打印```dp```数组

⚠️ 如果 dp 数组定义为以 `i` 和 `j` 结尾的，则 `dp[i][0]` 和 `dp[0][j]` 是有意义的，要用额外的 `for` 循环们来查找第一行和第一列，把一个数组中出现过另一个数组第一个元素的相应位置赋值为 `1`，增加代码量。