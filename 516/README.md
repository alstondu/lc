# 516.最长回文子序列

[Leedcode 链接🔗](https://leetcode.cn/problems/longest-palindromic-subsequence/description/)  
[Code](https://github.com/alstondu/lc/blob/main/516/516.cpp)

### 题目

给你一个字符串 `s` ，找出其中最长的回文子序列，并返回该序列的长度。

---

#### 示例：

#### 示例 1：

**输入**：`s = "bbbab"`

**输出**：`4`

**解释**：一个可能的最长回文子序列为 `"bbbb"` 。

#### 示例 2：

**输入**：`s = "cbbd"`

**输出**：`2`

**解释**：一个可能的最长回文子序列为 `"bb"` 。

---

### 算法:

最长回文子序列不同于字串/子数组，可以不连续。

如果一个字符串是回文的，且其左边的字符和右边的字符相同，则算上这两个字符的字符串也是回文的，根据这个原理，可以定义 dp 数组和递推公式。

1.  ```dp```数组定义：
	
	```dp[i][j]```表示使以下标为 `i ` 开头，以下标为 `j ` 结尾的字符串中最长回文子序列的长度。
			  		  	 
2. 递推公式：
	
	如果 `s[i] == s[j]`，那么 dp[i][j] 就是不包含着两个字符时的长度 + 2；
	
	否则，最大的长度将在二者考虑其一中产生，要么考虑 s[i]，长度为 dp[i][j - 1]，要么考虑 s[j]，长度为 dp[i + 1][j]，取大者。
	
  
3. ```dp``` 数组初始化：

	因为 `dp[i][j]` 是由 `dp[i + 1][j - 1]` 推导来的，逆向推导到源头是 `i == j` 的时候，只有一个元素，这个时候一定是回文的，所以初始化为 `1`。所以每一个 `i = j` 的情况都要初始化为 `1`。
	
4. 遍历顺序：
	
	因为```dp[i][j]```从 `dp[i + 1][j - 1]`  推导而来。所以 `i` 从大到小遍历，`j` 从 `i` 开始从小到大遍历。

  
5. 打印```dp```数组