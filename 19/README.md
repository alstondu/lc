# 19. 删除链表的倒数第N个节点

[Leedcode 链接🔗](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/)  
[Code](https://github.com/alstondu/lc/blob/main/19/19.cpp)

### 题目

只用一次扫描，删除给定链表的倒数第 ```n``` 个结点，并且返回链表的头结点。


#### 示例 1：

输入：```head = [1,2,3,4,5], n = 2```
输出：```[1,2,3,5]```

#### 示例 2：

输入：```head = [1], n = 1```
输出：```[]```

#### 示例 3：

输入：```head = [1,2], n = 1```
输出：```[1]```

### 思路：

一次扫描自然联想到双指针，但是单链表无法从右向左移动指针也无法直接查询末端节点，故都需要正向移动。

若扫描两次，```n``` 实际上是两次扫描时移动的差值。

使用dummyHead 以操作头节点 

### 算法: 双指针

快指针移动 ```n + 1``` 后， 两个指针同时移动直至快指针指向链表尾端


+ 创建 ```dummyHead```, 使 ```slow``` 和 ```fast``` 初始化指向 ```dummyHead``` 。
+ 利用 ```while``` 循环使 ```fast``` 移动 ```n``` 次，之后再额外移动一次。⚠️ 循环结束条件为 ```n-- && fast != NULL```。
+ 利用 ```while``` 循环使 ```fast``` 和 ```slow``` 同时移动直至 ```fast``` 为 ```NULL``` 。
+ 删除 ```slow``` 的下一节点。
+ 清理内存并返还 ```head``` 。


⚠️ ```fast``` 移动 ```n + 1``` 以使得当扫描结束时 ```slow``` 指向待删除节点的前一个节点。  
⚠️ 返回结果前重新令 ```head = dummyHead->next``` 以防原本的头节点被删除。
