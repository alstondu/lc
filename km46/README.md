# km46. 0-1背包

[Leedcode 链接🔗](https://kamacoder.com/problempage.php?pid=1046)  
[Code](https://github.com/alstondu/lc/blob/main/km46/km46.cpp)

### 题目

0-1 背包表示每个物品要么不选，要么只能选一次。

小明需要用背包携带一些占据不同的空间，并且具有不同的价值的物品。行李空间为 ```N```，应该如何抉择，才能携带最大价值的研究材料，每种研究材料只能选择一次，并且只有选与不选两种选择，不能进行切割。

**输入**：

第一行包含两个正整数，第一个整数 M 代表研究材料的种类，第二个正整数 N，代表小明的行李空间。

第二行包含 M 个正整数，代表每种研究材料的所占空间。 

第三行包含 M 个正整数，代表每种研究材料的价值。

**输出**：

输出一个整数，代表小明能够携带的研究材料的最大价值。

---

#### 示例

**输入**：

```6 1```

```2 2 3 1 5 2```

```2 3 1 5 4 3```

**输出**：

```5```

---

## 暴力解法

回溯，每个物品有取与不取两个状态，时间复杂度 ```O(2^n)```。


## 二维 dp 解法

1.  ```dp```数组定义：

	```dp[i][j]```：在 [0, i] 的范围内任取物品（物品 0 - 物品 i），背包容量为 j 的情况下，背包内能够放入物品的最大价值。也就是说，```dp[M][N]``` 就是所求。
	  	 
2. 递推公式：```dp[i][j] = max(dp[i - 1][j] + dp[i][j - weight[i]] + value[i])```

	当前的最优解 ```dp[i][j]``` 可以从只有 ```i - 1``` 样物品时的最优解推倒而来。第 ```i``` 件物品可以选择放还是不放，分别有一个最优解，二者比较取更优：
	1. 第 ```i``` 件不放，那么此时背包能承载最大重量就是 ```j```。最优解为重量为 ```j``` 时，在除去第 ```i``` 件以外的 ```i - 1``` 件中任选物品能获得的最大价值，也就是 ```dp[i - 1][j]```。
	2. 第 ```i``` 件放，那么要正好利用总共 ```j``` 的承载量的话，那么剩下的 ```i - 1``` 件总共占有的重量就是除去第 ```i``` 件的重量剩下的 ```j - weight[i]```。这种情况下最优解就是```dp[i - 1][j - weight[i]]```。当前的最优解就是在此最优解的基础上加上第 ```i``` 件的价值，也就是```dp[i - 1][j - weight[i]] + value[i]```
  
3. ```dp``` 数组初始化：
	
	当前的```dp[i][j]```是由```dp[i - 1][j]```和```dp[i - 1][j - weight[i]]```推出来的，分别位于其上方和左上方，因此表格的第一行和第一列需要初始化。
	
	第一列代表背包重量为 ```0```，因此无论从哪些物品中选取，最大价值都是 ```0```， 初始化为 ```0```。 
  
  	第一行是只选择物品 ```0``` 的时候，背包内物品的价值，只要重量放得下物品 ```0```，则初始化成物品 ```0``` 的价值。
  	
  	其它位置因为是从被初始化的位置推倒而来的，因此初始化什么无所谓。
  	
4. 遍历顺序：

	两层 for 循环，一层遍历物品，一层遍历背包。无论先遍历哪个，都可以保证当前的情况的上方和左上方都已经遍历并确定下来了，因此都可以。
  
5. 打印```dp```数组



## 一维 dp 解法

在二维 dp 数组解法中，当前的 dp 值是由其上一行的 dp 值推倒来的，因此相比于维护整个二维数组（表格），可以只维护一个数组（一行）。把上一行的值粘贴过来，然后实时更新。

1.  ```dp```数组定义：

	```dp[j]```：在当前的 [0, i] 下，背包容量为 j 的情况下，背包内能够放入物品的最大价值。当前的 i 反映在当前的 for 循环下。
	  	 
2. 递推公式：```dp[j] = max(dp[j] + dp[j - weight[i]] + value[i])```

	1. 第 ```i``` 件不放，那么此时背包能放入的最大价值保持不变，还是 ```dp[j]```。
	2. 第 ```i``` 件放，那么要正好利用总共 ```j``` 的承载量的话，那么剩下的 ```i - 1``` 件总共占有的重量就是除去第 ```i``` 件的重量剩下的 ```j - weight[i]```。这种情况下最优解就是```dp[j - weight[i]]```。当前的最优解就是在此最优解的基础上加上第 ```i``` 件的价值，也就是```dp[j - weight[i]] + value[i]```
  
3. ```dp``` 数组初始化：
	
	```dp[0]``` 表示背包可承载重量为 ```0```时的最大价值，因此为 ```0```, 因为其它的 ```dp``` 值都是从在其自身还有推倒值中选择最大选出来的，因此每一个 ```dp``` 值都应初始化为最小的非负数，也就是 ```0```。
  	
4. 遍历顺序：

	需要倒序遍历，因为当前的 ```dp[j]``` 的推倒用到了二维数组中的上一层前面的值（左上方），如果正序遍历则会在计算当前值之前把上一层前面的值覆盖掉。
	
	先遍历物品，再遍历背包载量。
  
5. 打印```dp```数组