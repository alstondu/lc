# 图论理论基础

## 构造方式

1. 邻接矩阵

	n 个 节点 需要 n * n 大小的二维数组（矩阵）
	
	`grid[2][5] = 6` 表示 节点 2 连接 节点5 为有向图，节点 2 指向节点 5，边的权值为 6。
	
	如果想表示无向图，即：`grid[2][5] = 6，grid[5][2] = 6`，表示节点 2 与 节点 5 相互连通，权值为 6。
	
	<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20240222110025.png" alt="">
	
	**缺点：**
	
	+ 边少，节点多的情况下，会导致申请过大的二维数组，造成空间浪费
	
	+ 寻找节点连接情况的时候，需要遍历整个矩阵，即 `n * n` 的时间复杂度，同样造成时间浪费

	**优点：**
	
	+ 稠密图，定点多，空间效率高
	
	+ 易于理解
	
	+ 检查两个顶点是否存在边非常快

2. 邻接表

	数组 + 链表（list），数组存定点，链表存边
	
	<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20240223103713.png" alt="">
	+ 节点1 指向 节点3 和 节点5
	+ 节点2 指向 节点4、节点3、节点5
	+ 节点3 指向 节点4
	+ 节点4指向节点1
	
	**缺点：**
	
	+ 检查任意两点间存不存在边复杂，需要 `O(V)` 时间，`V` 表示某节点连接其他节点的数量
	+ 实现相对复杂，不易理解

	**优点：**
	
	+ 稀疏图空间利用率高
	+ 遍历边容易

## 遍历方式

深度优先搜索（dfs）对应二叉树递归遍历和回溯

广度优先搜索（bfs）对应二叉树层序遍历

---
# km98. 所有可达路径

[Leedcode 链接🔗](https://kamacoder.com/problempage.php?pid=1170)  
[Code](https://github.com/alstondu/lc/blob/main/km98/km98.cpp)

### 题目

给定一个有 `n` 个节点的有向无环图，节点编号从 `1` 到 `n`。请编写一个函数，找出并返回所有从节点 `1` 到节点 `n` 的路径。每条路径应以节点编号的列表形式表示。

#### 输入描述

第一行包含两个整数 `N，M`，表示图中拥有 `N` 个节点，`M` 条边

后续 `M` 行，每行包含两个整数 `s` 和 `t`，表示图中的 `s` 节点与 `t` 节点中有一条路径

#### 输出描述

输出所有的可达路径，路径中所有节点之间空格隔开，每条路径独占一行，存在多条路径，路径输出的顺序可任意。如果不存在任何一条路径，则输出 `-1`。

注意输出的序列中，最后一个节点后面没有空格！ 例如正确的答案是 ``1 3 5``,而不是 ``1 3 5 ``， `5`后面没有空格！

---

#### 示例：

#### 示例 1:

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20240514103953.png" alt="">

**输入**：

```
5 5
1 3
3 5
1 2
2 4
4 5
```

**输出**：

```
1 3 5
1 2 4 5
```
或

```
1 2 4 5
1 3 5
```

---

### 算法:

#### 图存储

1. **邻接矩阵：**

	n 个节点，节点从 1 开始算，为了下标对其，创建 `(n + 1) * (n + 1)` 大小的矩阵, 矩阵的每个位置代表的是对应行列的两个节点之间边的值，全初始化为 0， 然后再根据输入把对应的有边的位置赋值。
	
	```c++
	while (m--){
		cin >> s >> t;
		grid[s][t] = 1;
	}
	```

2. **邻接表：**

	构建数组储存节点，大小为 `n + 1 `（对齐下标）
	
	```c++
	vector<list<int>> graph(n + 1);
	```
	把输入的边 push 到相应的节点的链表中
	
	```c++
	while (m--){
		cin >> s >> t;
		graph[s].push_back(t);
	}
```

递归 + 回溯

递归传入图，当前 int 节点，终止 int 节点

当前节点等于终止节点时递归结束，储存路径

遍历当前节点所能连接的所有节点，找到有边的节点进行递归和回溯