# 1143. 最长公共子序列

[Leedcode 链接🔗](https://leetcode.cn/problems/longest-common-subsequence/description/)  
[Code](https://github.com/alstondu/lc/blob/main/1143/1143.cpp)

### 题目

给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长公共子序列的长度。如果不存在 公共子序列 ，返回 `0` 。

一个字符串的子序列是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

例如，`"ace"` 是 `"abcde"` 的子序列，但 `"aec"` 不是 `"abcde"` 的子序列。两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。

---

#### 示例：

#### 示例 1：

**输入**：`text1 = "abcde", text2 = "ace"` 

**输出**：`3`  

**解释**：最长公共子序列是 `"ace"` ，它的长度为 `3` 。

#### 示例 2：

**输入**：`text1 = "abc", text2 = "abc"`

**输出**：`3`

**解释**：最长公共子序列是 `"abc"` ，它的长度为 `3` 。

#### 示例 3：

**输入**：`text1 = "abc", text2 = "def"`

**输出**：`0`

**解释**：两个字符串没有公共子序列，返回 `0` 。

---

### 算法:

 
1.  ```dp```数组定义：
	
	```dp[i][j]```表示在以下标为 `i - 1` 为结尾的 `text1` 和以下标为 `j - 1` 为结尾的 `text2` 的最长公共子序列的长度为 `dp[i][j]`。
		  		  	 
2. 递推公式：
	
	如果 text1[i - 1] = text2[j - 1], 那么除去这两个元素，dp[i][j] 要在其基础上 + 1。如果不相等，那么就看 text1[0, i - 2] 与 text2[0, j - 1] 的最长公共子序列 和 text1[0, i - 1] 与 text2[0, j - 2] 的最长公共子序列，取最大的。
  
3. ```dp``` 数组初始化：

	因为```dp[i][j]```表示在以 `i - 1` 和 `j - 1`为结尾的字符串，因此遍历时应该从 `i = 1` 和 `j = 1`开始，且 `dp[i][0]` 和 `dp[0][j]` 代表一个字符串和另一个空的字符串比，初始化为 0。
	
	其他的元素在没有找到共同字数组时为 `0`，代表重复字数组长度为 `0`。

4. 遍历顺序：
	
	从前向后遍历二维数组，但是边界条件为 `i` 和 `j`，代表下标为 `i - 1` 和 `j - 1` 的元素。
  
5. 打印```dp```数组

⚠️ 如果 dp 数组定义为以 `i` 和 `j` 结尾的，则 `dp[i][0]` 和 `dp[0][j]` 是有意义的，要用额外的 `for` 循环们来查找第一行和第一列，把一个数组中出现过另一个数组第一个元素的相应位置赋值为 `1`，增加代码量。

⚠️ 本题由于不要求连续，因此结果在遍历过程中是累加的（[Lc 718. 最长重复子数组](https://github.com/alstondu/lc/blob/main/718/README.md)是连续的，如果不相等会归零）因此最终返还的就是dp数据的末尾值，而不是遍历过程中的最大值。