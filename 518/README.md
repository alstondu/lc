# 518. 零钱兑换 II

[Leedcode 链接🔗](https://leetcode.cn/problems/coin-change-ii/description/)  
[Code](https://github.com/alstondu/lc/blob/main/518/518.cpp)

### 题目

给你一个整数数组 ```coins``` 表示不同面额的硬币，另给一个整数 ```amount``` 表示总金额。

请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 ```0``` 。

假设每一种面额的硬币有无限个。 

---

#### 示例：

#### 示例 1：

**输入**：```amount = 5, coins = [1, 2, 5]```

**输出**：```4```

**解释**：

有四种方式可以凑成总金额：

```5=5```

```5=2+2+1```

```5=2+1+1+1```

```5=1+1+1+1+1```

#### 示例 2：

**输入**：```amount = 3, coins = [2]```

**输出**：```0```

**解释**：

只用面额 ```2``` 的硬币不能凑成总金额 ```3``` 。

#### 示例 3：

**输入**：```amount = 10, coins = [10]``` 

**输出**：```1```

---

### 算法:

本题和 [Lc 494.目标和](https://github.com/alstondu/lc/blob/main/494/README.md) 一样，只不过这个是完全背包。

1.  ```dp```数组定义：

	  	```dp[j]```：有 ```dp[j]``` 种方法凑成金额```j```。
	  	 
2. 递推公式：
	```dp[j]```为一个滚动数组, 对于当前元素 ```i```, 可以选择装或者不装，不装的话，```dp[j]``` 保持不变，为上一轮的 ```dp[j]```，装的话为```dp[j - coins[i]]```, 因此递推公式为：
	```dp[j] = dp[j] + dp[j - coins[i]]```
  
3. ```dp``` 数组初始化：所有的 ```dp``` 数组的值都是由 ```dp[0]```推导来的。 ```dp[0]``` 初始化时代表有多少种方法凑成金额 ```0```, 只有一种，那就是什么都不取，因此初始化为 ```1```。
  
4. 遍历顺序：
	
	本题求的方法数是组合问题，```2 + 2 + 1``` 和 ```2 + 1 + 2```是一样的。应该先遍历物品再遍历背包。这样取一个面额的硬币来凑不同目标金额，再加入另一种硬币，凑不同金额可以防止重复的排列。
	
	如果先遍历背包再遍历物品，则每一个大小的背包都会遍历不同的硬币面额，产生重复的排列。
  
5. 打印```dp```数组
