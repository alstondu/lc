# 322. 零钱兑换

[Leedcode 链接🔗](https://leetcode.cn/problems/coin-change/description/)  
[Code](https://github.com/alstondu/lc/blob/main/322/322.cpp)

### 题目

给你一个整数数组 ```coins``` ，表示不同面额的硬币；以及一个整数 ```amount```，表示总金额。

计算并返回可以凑成总金额所需的最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 ```-1``` 。

你可以认为每种硬币的数量是无限的。

---

#### 示例：

#### 示例 1：

**输入**：```coins = [1, 2, 5], amount = 11```

**输出**：```3``` 

**解释**：

```11 = 5 + 5 + 1```

#### 示例 2：

**输入**：```coins = [2], amount = 3```
**输出**：```-1```

#### 示例 3：

**输入**：```coins = [1], amount = 0```

**输出**：```0```

---

### 算法:

可重复选，完全背包。

1.  ```dp```数组定义：

	  	```dp[j]```：最少需要 ```dp[j]``` 个硬币凑成金额```j```。
	  	 
2. 递推公式：
	```dp[j]```为一个滚动数组, 对于当前元素 ```i```, 可以选择装或者不装，不装的话，最小数量为 ```dp[j]```，装的话为```dp[j - coins[i]] + 1```, 因此递推公式为：
	```dp[j] = min(dp[j], dp[j - coins[i]] + 1)```
  
3. ```dp``` 数组初始化：```dp[0]``` 代表有最少需要多少个硬币凑成面额 ```0```，自然为 ```0```。下表不为 ```0``` 的数组代表需要至少多少个硬币凑成相应面值，应初始化为一个尽可能大的数，因为递推的时候要取最小值。可以初始化为 ```amount + 1```, 因为即使只取 ```1```, 凑成 ```amount``` 最多需要的硬币数也不会超过 ```amount```。
	
	按照这种方法，如果遍历结束后的结果仍然大于 ```amount```, 也就代表目标面值凑不出来，```return -1```。

4. 遍历顺序：
	
	求元素个数不同于求组合或者排列，物品和背包的遍历顺序对结果没有影响。因此可以先物品后背包，正序遍历。
  
5. 打印```dp```数组
