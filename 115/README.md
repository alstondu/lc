# 115. 不同的子序列

[Leedcode 链接🔗](https://leetcode.cn/problems/distinct-subsequences/description/)  
[Code](https://github.com/alstondu/lc/blob/main/115/115.cpp)

### 题目

给你两个字符串 `s` 和 `t` ，统计并返回在 `s` 的 子序列 中 `t` 出现的个数。
---

#### 示例：

#### 示例 1：

**输入**：`s = "rabbbit", t = "rabbit"`

**输出**：`3`

**解释**：

如下所示, 有 `3` 种可以从 `s` 中得到 `"rabbit"` 的方案。

_rabb_b_it_

_ra_b_bbit_

_rab_b_bit_

#### 示例 2：

**输入**：`s = "babgbag", t = "bag"`

**输出**：`5`

**解释**：

如下所示, 有 `5` 种可以从 `s` 中得到 `"bag"` 的方案。 

_ba_b_g_bag

_ba_bgba_g_

_b_abgb_ag_

ba_b_gb_ag_

babg_bag_

---

### 算法:

1.  ```dp```数组定义：
	
	```dp[i][j]```表示在以下标为 `i - 1` 为结尾的 `s` 包含以下标为 `j - 1` 为结尾的 `t` 的数量为 `dp[i][j]`。
		  		  	 
2. 递推公式：
	
	遍历 `t` 然后遍历 `s`，对于当前的 `t`，如果新来的 `s` 元素不等于 `t` 的最后一个元素，也就是 `s[j - 1] != t[i - 1]`，那么数量不变，`dp[i][j] = dp[i][j - 1]`;
	
	如果 `s[j - 1] == t[i - 1]`，那么除了用原本的 `s` 匹配 `t`的方法之外，还要加上以 `s[j - 1]` 匹配 `t[i - 1]` 的那些情况，这样的情况下多出来的方法就是不考虑二者最后的元素，其它元素相匹配的方法数，也就是 `dp[i - 1][j - 1]`。
	
	**例子**：假设当前遍历到的 `t` 是 `bag`，`s` 是 `babga`，此时 `s` 又来了一个 `g`， 和当前 `t` 的最后一个元素相同了。这个时候新的 `babgag` 含有 `bag` 的数量是在 `babga` 原本包含的 `bag` 数量（`dp[i][j - 1]`）的基础上，增加了使用新来的 `g` 新组成的 `bag` 数量。新来的 `g` 能组成多少个`bag`，其实是原本的 `babga` 包含多少个 `ba`。也就是 `dp[i - 1][j - 1]`。
  
3. ```dp``` 数组初始化：

	因为```dp[i][j]```表示在以 `i - 1` 和 `j - 1`为结尾的字符串，因此遍历时应该从 `i = 1` 和 `j = 1`开始，且 `dp[i][0]` 表示 s 为 空时包含 t 的数量，为 0， `dp[0][j]` 表示 t 为空时，s 包含 t 的数量，为 1.。

4. 遍历顺序：
	
	从前向后遍历二维数组，但是边界条件为 `i` 和 `j`，代表下标为 `i - 1` 和 `j - 1` 的元素。
  
5. 打印```dp```数组