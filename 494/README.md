# 494. 目标和

[Leedcode 链接🔗](https://leetcode.cn/problems/target-sum/description/)  
[Code](https://github.com/alstondu/lc/blob/main/494/494.cpp)

### 题目

给你一个非负整数数组 ```nums``` 和一个整数 ```target``` 。

向数组中的每个整数前添加 ```'+'``` 或 ```'-'``` ，然后串联起所有整数，可以构造一个表达式 ：

例如，```nums = [2, 1]``` ，可以在 ```2``` 之前添加 ```'+'``` ，在 ```1``` 之前添加 ```'-'``` ，然后串联起来得到表达式 ```"+2-1"``` 。

返回可以通过上述方法构造的、运算结果等于 ```target``` 的不同表达式的数目。


---

#### 示例：

#### 示例 1：

**输入**：```nums = [1,1,1,1,1], target = 3```

**输出**：```5```

**解释**：

一共有 5 种方法让最终目标和为 3 。
````
-1 + 1 + 1 + 1 + 1 = 3```

```+1 - 1 + 1 + 1 + 1 = 3```

```+1 + 1 - 1 + 1 + 1 = 3```

```+1 + 1 + 1 - 1 + 1 = 3```

```+1 + 1 + 1 + 1 - 1 = 3```

#### 示例 2：

**输入**：```nums = [1], target = 1```

**输出**：```1```

---

### 算法:

整个数组可以看成一堆正值和一堆负值，如果能把其中一堆的值表示出来，则可以看作是 0-1 背包问题中背包的载量。正值，负值，总和还有目标值之间满足数量关系：

正 + 负 = 总

正 - 负 = 目标

可以推出：正 = （总 + 目标）/2（若有余数，则没有办法装满背包）

问题转换成了从整个数组中任意取值，有多少种方法装满载量为 “正” 的背包。

1.  ```dp```数组定义：

	  	```dp[j]```：有 ```dp[j]``` 种方法装满载量为 ```j``` 的背包。
	  	 
2. 递推公式：
	```dp[j]```为一个滚动数组, 对于当前元素 ```i```, 可以选择装或者不装，不装的话，```dp[j]``` 保持不变，为上一轮的 ```dp[j]```，装的话为```dp[j - nums[i]]```, 因此递推公式为：
	```dp[j] = dp[j] + dp[j - nums[i]]```
  
3. ```dp``` 数组初始化：所有的 ```dp``` 数组的值都是由 ```dp[0]```推导来的。 ```dp[0]``` 初始化时代表只有下标 ```i = 0``` 的元素时，几种方法装满载量为 ```0``` 的包，只有一种选择，那就是不装，因此初始化为 ```1```。（问题已经被转化为背包了，因此不用考虑正负号了，只考虑装还是不装，递推公式也是这么来的）。
  
4. 遍历顺序：先元素后背包，倒叙。
  
5. 打印```dp```数组
