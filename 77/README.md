# 回溯算法

## 解决问题

+ 组合问题：N个数里面按一定规则找出k个数的集合
+ 切割问题：一个字符串按一定规则有几种切割方式
+ 子集问题：一个N个数的集合里有多少符合条件的子集
+ 排列问题：N个数按一定规则全排列，有几种排列方式
+ 棋盘问题：N皇后，解数独等等

	排列强调顺序，组合不强调顺序

## 理解

回溯问题都可以抽象为**树形结构**，

因为回溯法解决的都是在集合中递归查找子集，集合的大小就构成了树的宽度，递归的深度就构成了树的深度。

## 模版

```c++
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```


# 77. 组合

[Leedcode 链接🔗](https://leetcode.cn/problems/combinations/description/)  
[Code](https://github.com/alstondu/lc/blob/main/77/77.cpp)

### 题目
给定两个整数 ```n``` 和 ```k```，返回范围 ```[1, n]``` 中所有可能的 ```k``` 个数的组合（任何顺序）。


### 算法：

**横向 ```for``` 循环**（单层逻辑）：

遍历数组内未取到过的数字（组合不强调顺序，不重复）。

利用 ```startIdx``` 逐层递增来限制循环遍历的范围。


**纵向递归：**

每一层向下递归将 ```for``` 循环遍历到的数字存入```path```, 直到数组内元素数量等于 ```k```，```return```（中止条件）。

回溯：递归回到上层后需要将之间存入的元素 ```pop```出来

### 剪枝

如果for循环选择的起始位置之后的元素个数已经不足所需元素个数了，搜索到该 ```branch```叶子处数组内元素也不会到达 ```k```, 因此可以根据这个数量关系来限制 ```for``` 循环次数，不去遍历一些 “枝”，故名曰“剪枝”

**关系：(```path``` 仍需元素个数) <= (此时所剩未遍历元素个数)**

```path``` 仍需元素个数： $k - path(size)$

此时所剩未遍历元素个数： $n - i + 1$

	⚠️ $+ 1$ 是因为本题中 ```i``` 从 $1$ 开始，当 ```path```中还没有元素时，未遍历元素应该是 ```n``` 而不是 ```n - 1```。

➡️ $i  <= n - (k - path.size() ) + 1$




