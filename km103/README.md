# km103. 水流问题

[Leedcode 链接🔗](https://kamacoder.com/problempage.php?pid=1175)  
[Code](https://github.com/alstondu/lc/blob/main/km103/km103.cpp)

### 题目

现有一个 `N × M` 的矩阵，每个单元格包含一个数值，这个数值代表该位置的相对高度。矩阵的左边界和上边界被认为是第一组边界，而矩阵的右边界和下边界被视为第二组边界。


矩阵模拟了一个地形，当雨水落在上面时，水会根据地形的倾斜向低处流动，但只能从较高或等高的地点流向较低或等高并且相邻（上下左右方向）的地点。我们的目标是确定那些单元格，从这些单元格出发的水可以达到第一组边界和第二组边界。

#### 输入描述

第一行包含两个整数 `N` 和 `M`，分别表示矩阵的行数和列数。 

后续 `N` 行，每行包含 `M` 个整数，表示矩阵中的每个单元格的高度。

#### 输出描述

输出共有多行，每行输出两个整数，用一个空格隔开，表示可达第一组边界和第二组边界的单元格的坐标，输出顺序任意。

---

#### 示例：

#### 示例 1:

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20240517115816.png" alt="">

图中的蓝色方块上的雨水既能流向第一组边界，也能流向第二组边界。所以最终答案为所有蓝色方块的坐标。

**输入**：

```
5 5
1 3 1 2 4
1 2 1 3 2
2 4 7 2 1
4 5 6 1 1
1 4 1 2 1
```

**输出**：

```
0 4
1 3
2 2
3 0
3 1
3 2
4 0
4 1
```

---

### 算法:

直白的方法是遍历每个格子，对于单个格子进行 dfs/bfs，判断其是否能同时流到两个边界。每个格子搜索的时间复杂度是 `m*n`， 共有`m*n` 个格子，总共时间复杂度为 `O(m^2*n^2)`。

优化的方法可以从边界位置“逆流而上”，标记从第一边界和第二边界出发能流经的所有格子，然后取交集。因为搜索过程中 visited 的位置是会跳过的，所以看似从每个边界位置出发都进行了一次搜索，实际上只搜索了两次，所以时间复杂度是 `2*m*n + m*n`，也就是 `O(m*n)`	。空间复杂度是 `O(m*n)`，开辟了几个 `m*n` 的 grid。