# 1049. 最后一块石头的重量 II

[Leedcode 链接🔗](https://leetcode.cn/problems/last-stone-weight-ii/description/)  
[Code](https://github.com/alstondu/lc/blob/main/1049/1049.cpp)

### 题目

有一堆石头，用整数数组 ```stones``` 表示。其中 ```stones[i]``` 表示第 ```i``` 块石头的重量。

每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 ```x``` 和 ```y```，且 ```x <= y```。那么粉碎的可能结果如下：

如果 ```x == y```，那么两块石头都会被完全粉碎；
如果 ```x != y```，那么重量为 ```x``` 的石头将会完全粉碎，而重量为 ```y``` 的石头新重量为 ```y-x```。
最后，最多只会剩下一块石头。返回此石头最小的可能重量。如果没有石头剩下，就返回 ```0```。


---

#### 示例：

#### 示例 1：

**输入**：```stones = [2,7,4,1,8,1]```

**输出**：```1```

**解释**：

组合 ```2``` 和 ```4```，得到 ```2```，所以数组转化为 ```[2,7,1,8,1]```，

组合 ```7``` 和 ```8```，得到 ```1```，所以数组转化为 ```[2,1,1,1]```，

组合 ```2``` 和 ```1```，得到 ```1```，所以数组转化为 ```[1,1,1]```，

组合 ```1``` 和 ```1```，得到 ```0```，所以数组转化为 ```[1]```，这就是最优值。

#### 示例 2：

**输入**：```stones = [31,26,33,21,40]```

**输出**：```5```

---

### 算法:

尽量把石头分成重量大小相同的两堆，两堆的差值就是最终结果。

取一个重量大小为 ```sum/2``` 的背包，尽可能把它装满，即可把石头分成重量大小为总重量一半的石头。这和 [Lc 416.分割等和子集](https://github.com/alstondu/lc/blob/main/416/README.md) 的思路不谋而合了。

1.  ```dp```数组定义：

	  	```dp[j]```：载量为 ```j``` 的背包（石头堆）能承载的最大石头重量。
	  	 
2. 递推公式：```dp[j] = dp[j] + dp[j - stones[i]] + stones[i]```
  
3. ```dp``` 数组初始化：```dp[0]``` 初始化为 ```0```，因为载量为 ```0``` 的背包里面的石头重量肯定是 ```0```，其它 ```dp``` 元素也初始化为 ```0```，以避免取最大值时喧宾夺主。
  
4. 遍历顺序：先石头，后石头堆，从后向前。
  
5. 打印```dp```数组
