# 474. 一和零

[Leedcode 链接🔗](https://leetcode.cn/problems/ones-and-zeroes/description/)  
[Code](https://github.com/alstondu/lc/blob/main/474/474.cpp)

### 题目

给你一个二进制字符串数组 ```strs``` 和两个整数 ```m``` 和 ```n``` 。

请你找出并返回 ```strs``` 的最大子集的长度，该子集中最多有 ```m``` 个 ```0``` 和 ```n``` 个 ```1``` 。

如果 ```x``` 的所有元素也是 ```y``` 的元素，集合 ```x``` 是集合 ```y``` 的子集。

---

#### 示例：

#### 示例 1：

**输入**：```strs = ["10", "0001", "111001", "1", "0"], m = 5, n = 3```

**输出**：```4```

**解释**：

最多有 ```5``` 个 ```0``` 和 ```3``` 个 ```1``` 的最大子集是 ```{"10","0001","1","0"}``` ，因此答案是 ```4``` 。

其他满足题意但较小的子集包括 ```{"0001","1"}``` 和 ```{"10","1","0"}``` 。```{"111001"}``` 不满足题意，因为它含 ```4``` 个 ```1``` ，大于 ```n``` 的值 ```3``` 。

#### 示例 2：

**输入**：```strs = ["10", "0", "1"], m = 1, n = 1```

**输出**：```2```

**解释**：

最大的子集是 ```{"0", "1"}``` ，所以答案是 ```2```。

---

### 算法:

本题的背包是有两个维度的，分别为 ```m``` 和 ```n```。但由于数组中的字符串还是每个只能取一次，依然是个 ```0-1``` 背包。

1.  ```dp```数组定义：

	三维压缩到二维，依然是物品数量的维度被压缩了，但是之前的背包承载量现在是 ```m``` 和 ```n``` 两个维度，所以是二维。根据所求，```dp[i][j]``` 定义为子集中共含有 ```i``` 个 ```0``` 和 ```j``` 个 ```1```，最大元素个数。```dp[m][n]``` 即为所求。

	  	 
2. 递推公式：

	若当前字符串含有 ```x``` 个 ```0``` 和 ```y``` 个 ```1```，则把它放到子集之前的子集中含有```dp[i - x][j - y]```个元素，放入之后元素个数 ```+ 1```，因此递推公式为：
	```dp[i][j] = max(dp[i - x][j - y] + 1, dp[i][j]```
  
3. ```dp``` 数组初始化：```dp[0][0]``` 表示子集中没有 ```0``` 或 ```1``` 时元素最大数量，为 ```0```，其它 ```dp``` 元素为了取 ```max```能得到正确的推导，也设为 ```0```。
  
4. 遍历顺序：先物品后背包，遍历背包倒叙，这里因为背包是二维所以需要嵌套两层遍历。
  
5. 打印```dp```数组
